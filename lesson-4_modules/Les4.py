from Les4_Module import input_check, input_check1, input_check2, input_check3

# Задание #1

#Тело основной программы
def bubble():
    # Функция для генерации рандомных чисел
    
    # Длина массива определяется числом n
    n, mas = input_check()

    # Здесь отображается массив, который мы будем сортировать
    print(f'Сортируемый массив:     {mas}')
    # count будет подсчитывать, сколько раз пришлось произвести замену между числами
    count = 0
    # Для того чтобы выполнить сравнения всех чисел внутри списка, нам нужно запустить цикл столько раз, сколько и чисел в списке.
    # (В конце цикла каждое наибольшее обнаруженное число будет сдвигаться к концу списка).
    # Так как последнее оставшееся число в последний цикл всегда будет самым наименьшим из списка
    # (так как все остальные уже отсортированы), то для оптимизации мы запускаем цикл на один раз меньше.
    for run in range(n-1):
        # Для выполнения цикла мы ставим значение range(n-1) для того, чтобы не получить ситуацию, когда мы 
        # сравниваем последнее в списке число i с несуществующим числом i+1.
        # Для оптимизации программы мы добавляем в цикл приписку -run. 
        # После первого исполнения цикла в конце списка окажется наибольшее число из списка.
        # Таким образом, нам уже не обязательно делать сравнение с последним числом. 
        # Соответсвенно, после второго исполнения цикла нам не требуется проверять уже два последних числа в списке.
        # С началом каждого цикла мы будем проверять всё меньше и меньше чисел, если добавим в range -run.
        # Это будет уменьшать диапазон обращения к списку на необходимое значение
        for i in range(n-1-run):
            if mas[i] > mas[i+1]:
                count += 1
                mas[i], mas[i+1] = mas[i+1], mas[i]

    print(f'Отсортированный массив: {mas}\nЧисло замен: {count}')

#Меню для запуска программы
while True:
    next_step = input("""
                        Выберите задачу.
                        Алгоритм сортировки списка пузырьковым методом:    1
                        Выход:                                             Enter
                     """)
    if not next_step:
        print("До свидания...")
        break
    elif next_step == "1":
        bubble()
    else:
        print("Повторите ввод...")




# Задание #2

a, b = input_check1()

print(f"""
        Введенный список №1:                      {a}
        Введенный список №2:                      {b}
      """)

c = list(set(a) & set(b))
print('Совпадающие множества введенных списков:', c)


# Задание 4


list_two = []

list_one = input_check2()

print(f'Введенный список:       {list_one}')

# 1 способ - на выходе список с другой последовательностю измененного списка

# print(list_one)
# list_two = list(set(list_one))
# print(list_two)       

# 2 способ - с сохранением последовательности изначального списка 

for value in list_one:
    try:
        list_two.index(value)
    except:
        list_two.append(value)
list_one.clear()
for value in list_two:
    list_one.append(value)
list_two.clear()
print(f'Отсортированный список: {list_one}')


# Задание 5

str_inp = input_check3()

print('Строка введена верно')

def check(string):
    brackets_open = ('(', '[', '{', '<')
    brackets_closed = (')', ']', '}', '>')
    stack = []
    for i in string:
        if i in brackets_open: #если в данном индексе есть какая-либо из открывающегося типа скобок, то
            stack.append(i) #то добавляем её в стэк
        if i in brackets_closed:#если вдруг открывающейся скобки такого же типа не было, а мы нашли только закрывающююся скобку то ...    
            if len(stack) == 0:#то в стэк мы ничего не добавляли значит его длина равна 0 и скобки расставлены неверно
                return False
            index = brackets_closed.index(i) #сюда мы перешли, если открывающаяся скобка и закрывающаяся совпадают - кладем в значение index, индекс закрывающейся скобки
            open_bracket = brackets_open[index]#в переменную open_bracket кладем открывающейся скобку по раннее полученному индексу
            if stack[-1] == open_bracket:#идем в обратную сторону по стэку для удаления всех скобок если они расставлены правильно(нужно, чтобы очистить стэк), если он пустой то цикл завершается
                stack = stack[:-1]  
            else: return False  
    return (not stack)

if check(str_inp) == True:
    print('Скобки в введенной вами строке написаны верно')
else:
    print('Скобки в вашей строке расставлены неверно')